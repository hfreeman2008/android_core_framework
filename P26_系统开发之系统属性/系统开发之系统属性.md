
# P26: 系统开发之系统属性

<img src="../flower/flower_p26.png">

---

[<font face='黑体' color=#ff0000 size=40 >跳转到文章结尾</font>](#结束语)

---

# 前言

系统属性是我们开发用的最多的一个技术点，以前觉得这个太简单了，没有什么需要了解的；后来想整体了解一下其具体的实现，发现事情没有那边简单啊。



本笔记主要是基于android 11，同步参考--Android 系统属性（SystemProperties）介绍（https://juejin.cn/post/7274932704453672972#heading-0）。

---

# 常用技巧

读取所有设备的系统属性：

```sh
adb shell getprop
```

读取对应的系统属性值（以sys.boot.reason为例）：


```sh
adb shell getprop sys.boot.reason
```

设置系统属性值（这个需要注意，许多系统属性值需要权限）：

```sh
adb shell setprop log.tag.stats_log D
```

监听系统属性值状态：

system/core/rootdir/init.rc

```sh
on property:vold.decrypt=trigger_restart_framework
    # A/B update verifier that marks a successful boot.
    exec_start update_verifier
    class_start_post_data hal
    class_start_post_data core
    class_start main
    class_start late_start
    setprop service.bootanim.exit 0
    start bootanim
```

---

# 代码中使用属性

## java代码调用

### 对于有系统权限的应用

我们可以直接使用SystemProperties的读写接口：

```java
import android.os.SystemProperties;

SystemProperties.set("sys.boot_completed", "1");
int max = SystemProperties.getInt("tombstoned.max_anr_count", 64);

```



这要求android程序的权限提升到system权限，方法有下面二个：

- 1、在AndroidManifest.xml中，在manifest加入android:sharedUserId="android.uid.system"。

- 2、在Android.mk中，將LOCAL_CERTIFICATE := XXX修改成LOCAL_CERTIFICATE := platform。

---

### 普通应用

由于SystemProperties.java的API为系统API，普通应用无法直接使用，可以通过反射来get和set prop。

```java
package com.android.reflectiondemo;

import androidx.appcompat.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.d(TAG, "sys.isolated_storage_snapshot:"+getBoolean("sys.isolated_storage_snapshot", false));
    }
    
    public static boolean getBoolean(String key, boolean def) throws IllegalArgumentException {
        try {
            Class SystemPropertiesClass = Class.forName("android.os.SystemProperties");
            Method getBooleanMethod =
                    SystemPropertiesClass.getDeclaredMethod(
                            "getBoolean", String.class, boolean.class);
            getBooleanMethod.setAccessible(true);
            return (boolean) getBooleanMethod.invoke(SystemPropertiesClass, key, def);
        } catch (InvocationTargetException
                | IllegalAccessException
                | NoSuchMethodException
                | ClassNotFoundException e) {
            Log.e(TAG, "Failed to invoke SystemProperties.getBoolean()", e);
        }
        return def;
    }
}

```



---

## c++代码调用

这里以MPEG4Writer.cpp为例

frameworks\av\media\libstagefright\MPEG4Writer.cpp

```c++
#include <cutils/properties.h>
    ...
void MPEG4Writer::addDeviceMeta() {
    ...
    if (property_get("ro.build.version.release", val, NULL)
    ...
        if (property_get("ro.product.model", val, NULL)
    ...
}

```

在C++代码中使用prop需要：
- include <cutils/properties.h>
- Android.mk或Android.bp或Makefile中需要链接libcutils库

```sh
shared_libs: [
        ...
        "libcutils",
        ...

```

properties.h源码在：

system/core/libcutils/include/cutils/properties.h

```c
int property_get(const char* key, char* value, const char* default_value);
int property_set(const char *key, const char *value);
int property_list(void (*propfn)(const char *key, const char *value, void *cookie), void *cookie)
```

libcutils库文件：

```sh
/system/lib64/libcutils.so
/system/lib/libcutils.so
```



---

# 涉及的代码路径汇总如下

```sh
app
SystemProperties#get  SystemProperties#set

framework：
frameworks\base\core\java\android\os\SystemProperties.java

jni:
frameworks\base\core\jni\android_os_SystemProperties.cpp

system:
system\core\base\properties.cpp
system\core\init\init.cpp
system\core\init\property_service.cpp
system\core\init\main.cpp
system\core\property_service\libpropertyinfoparser\property_info_parser.cpp

bionic:
bionic\libc\bionic\system_property_set.cpp
bionic\libc\bionic\system_property_api.cpp
bionic\libc\system_properties\system_properties.cpp
bionic\libc\include\sys\_system_properties.h
bionic\libc\include\sys\system_properties.h
bionic\libc\system_properties\contexts_serialized.cpp
bionic\libc\system_properties\prop_area.cpp
```

---

# 系统属性架构设计如下

![系统属性架构设计](系统属性架构设计.png)


---

# 系统属性整体分层

![系统属性整体分层](系统属性整体分层.png)

---

# 系统属性时序图

![系统属性时序图](系统属性时序图.png)


---

# 系统属性读写的流程

## frameworks-SystemProperties.java 
frameworks\base\core\java\android\os\SystemProperties.java 

读写系统属性的接口：

```java
public class SystemProperties {

    private static native String native_get(long handle);
    private static native void native_set(String key, String def);

    public static String get(@NonNull String key, @Nullable String def) {
        if (TRACK_KEY_ACCESS) onKeyAccess(key);
        return native_get(key, def);
    }
    
    public static void set(@NonNull String key, @Nullable String val) {
        if (val != null && !val.startsWith("ro.") && val.length() > PROP_VALUE_MAX) {
            throw new IllegalArgumentException("value of system property '" + key
                    + "' is longer than " + PROP_VALUE_MAX + " characters: " + val);
        }
        if (TRACK_KEY_ACCESS) onKeyAccess(key);
        native_set(key, val);
    }
}
```

通过JNI调用native_set()和native_get()：

---

## jni-android_os_SystemProperties.cpp
frameworks\base\core\jni\android_os_SystemProperties.cpp

```c++
//读
jstring SystemProperties_getSS(JNIEnv* env, jclass clazz, jstring keyJ,
                               jstring defJ)
{
    jstring ret = defJ;
    //读取系统属性
    ReadProperty(env, keyJ, [&](const char* value) {
        if (value[0]) {
            ret = env->NewStringUTF(value);
        }
    });
    if (ret == nullptr && !env->ExceptionCheck()) {
      ret = env->NewStringUTF("");  // Legacy behavior
    }
    return ret;
}

//写
void SystemProperties_set(JNIEnv *env, jobject clazz, jstring keyJ,
                          jstring valJ)
{
    ......
    bool success;
#if defined(__BIONIC__)
    //如果支持__BIONIC__
    success = !__system_property_set(key.c_str(), value ? value->c_str() : "");
#else
    //不支持__BIONIC__
    success = android::base::SetProperty(key.c_str(), value ? value->c_str() : "");
#endif
    if (!success) {
        jniThrowException(env, "java/lang/RuntimeException",
                          "failed to set system property (check logcat for reason)");
    }
}

//读
void ReadProperty(JNIEnv* env, jstring keyJ, Functor&& functor)
{
#if defined(__BIONIC__)
    //支持__BIONIC__
    const prop_info* prop = __system_property_find(key.c_str());
    if (!prop) {
        return;
    }
    ReadProperty(prop, std::forward<Functor>(functor));
#else
    //不支持__BIONIC__
    std::forward<Functor>(functor)(
        android::base::GetProperty(key.c_str(), "").c_str());
#endif
}

```


```c++
int register_android_os_SystemProperties(JNIEnv *env)
{
    const JNINativeMethod method_table[] = {
        { "native_get",
          "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
          (void*) SystemProperties_getSS },
        { "native_get_int", "(Ljava/lang/String;I)I",
          (void*) SystemProperties_get_integral<jint> },
        { "native_get_long", "(Ljava/lang/String;J)J",
          (void*) SystemProperties_get_integral<jlong> },
        { "native_get_boolean", "(Ljava/lang/String;Z)Z",
          (void*) SystemProperties_get_boolean },
        { "native_find",
          "(Ljava/lang/String;)J",
          (void*) SystemProperties_find },
        { "native_get",
          "(J)Ljava/lang/String;",
          (void*) SystemProperties_getH },
        { "native_get_int", "(JI)I",
          (void*) SystemProperties_get_integralH<jint> },
        { "native_get_long", "(JJ)J",
          (void*) SystemProperties_get_integralH<jlong> },
        { "native_get_boolean", "(JZ)Z",
          (void*) SystemProperties_get_booleanH },
        { "native_set", "(Ljava/lang/String;Ljava/lang/String;)V",
          (void*) SystemProperties_set },
        { "native_add_change_callback", "()V",
          (void*) SystemProperties_add_change_callback },
        { "native_report_sysprop_change", "()V",
          (void*) SystemProperties_report_sysprop_change },
    };
    return RegisterMethodsOrDie(env, "android/os/SystemProperties",
                                method_table, NELEM(method_table));
}
```



---

## system libbase库

```sh
vendor/lib64/libbase64.so
vendor/lib/libbase64.so
system/lib64/libbase.so
bengal/system/lib/libbase.so
```

android::base::GetProperty和android::base::SetProperty，调用的就是system libbase库中对应的文件：


system\core\base\properties.cpp

```c++
//读
std::string GetProperty(const std::string& key, const std::string& default_value) {
  std::string property_value;
#if defined(__BIONIC__)
  const prop_info* pi = __system_property_find(key.c_str());
  if (pi == nullptr) return default_value;

  __system_property_read_callback(pi,
                                  [](void* cookie, const char*, const char* value, unsigned) {
                                    auto property_value = reinterpret_cast<std::string*>(cookie);
                                    *property_value = value;
                                  },
                                  &property_value);
#else
  //读取系统属性
  auto it = g_properties.find(key);
  if (it == g_properties.end()) return default_value;
  property_value = it->second;
#endif
  // If the property exists but is empty, also return the default value.
  // Since we can't remove system properties, "empty" is traditionally
  // the same as "missing" (this was true for cutils' property_get).
  return property_value.empty() ? default_value : property_value;
}

//写
bool SetProperty(const std::string& key, const std::string& value) {
  return (__system_property_set(key.c_str(), value.c_str()) == 0);
}

#if !defined(__BIONIC__)
//这个是系统属性map
static std::map<std::string, std::string>& g_properties = *new std::map<std::string, std::string>;
static int __system_property_set(const char* key, const char* value) {
  //写
  g_properties[key] = value;
  return 0;
}
#endif
```

---

## bionic
bionic\libc\include\sys_system_properties.h

定义了系统属性服务名和系统属性文件：

```sh
#define PROP_SERVICE_NAME "property_service"
#define PROP_FILENAME "/dev/__properties__"
```


__system_property_set调用的写系统属性接口为：

bionic\libc\bionic\system_property_set.cpp

```c++
__BIONIC_WEAK_FOR_NATIVE_BRIDGE
int __system_property_set(const char* key, const char* value) {
    ......
  if (g_propservice_protocol_version == kProtocolVersion1) {
    // Old protocol does not support long names or values
    if (strlen(key) >= PROP_NAME_MAX) return -1;
    if (strlen(value) >= PROP_VALUE_MAX) return -1;

    prop_msg msg;
    memset(&msg, 0, sizeof msg);
    msg.cmd = PROP_MSG_SETPROP;
    strlcpy(msg.name, key, sizeof msg.name);
    strlcpy(msg.value, value, sizeof msg.value);

    return send_prop_msg(&msg);//发送PROP_MSG_SETPROP命令
  } else {
    // New protocol only allows long values for ro. properties only.
    if (strlen(value) >= PROP_VALUE_MAX && strncmp(key, "ro.", 3) != 0) return -1;
    // Use proper protocol
    PropertyServiceConnection connection;
    if (!connection.IsValid()) {
      errno = connection.GetLastError();
      async_safe_format_log(
          ANDROID_LOG_WARN, "libc",
          "Unable to set property \"%s\" to \"%s\": connection failed; errno=%d (%s)", key, value,
          errno, strerror(errno));
      return -1;
    }

    SocketWriter writer(&connection);//通过Socket与property_service进行通信
    if (!writer.WriteUint32(PROP_MSG_SETPROP2).WriteString(key).WriteString(value).Send()) {
      errno = connection.GetLastError();
      async_safe_format_log(ANDROID_LOG_WARN, "libc",
                            "Unable to set property \"%s\" to \"%s\": write failed; errno=%d (%s)",
                            key, value, errno, strerror(errno));
      return -1;
    }
    ......
    return 0;
  }
```

bionic\libc\bionic\system_property_api.cpp

```sh
static SystemProperties system_properties;

__BIONIC_WEAK_FOR_NATIVE_BRIDGE
//读
const prop_info* __system_property_find(const char* name) {
  return system_properties.Find(name);
}
```

---

## /dev/properties
此文件夹文件众多


```sh
properties_serial                                              u:object_r:system_lmk_prop:s0
property_info                                                  u:object_r:system_prop:s0
u:object_r:adbd_config_prop:s0                                 u:object_r:system_radio_prop:s0
```

---

# 属性服务-property_service

Socket与property_service来通信进行设置系统属性服务的值

## (1)启动属性服务
system\core\init\init.cpp

```c++
int SecondStageMain(int argc, char** argv) {
    ......
    PropertyInit();
    StartPropertyService(&property_fd);//
    ......  
}
```

---

## (2)属性初始化
system\core\init\property_service.cpp


```c++
void PropertyInit() {
    selinux_callback cb;
    cb.func_audit = PropertyAuditCallback;
    selinux_set_callback(SELINUX_CB_AUDIT, cb);

    mkdir("/dev/__properties__", S_IRWXU | S_IXGRP | S_IXOTH);
    CreateSerializedPropertyInfo();//创建属性信息property_info
    if (__system_property_area_init()) {//创建共享内存
        LOG(FATAL) << "Failed to initialize property area";
    }
    if (!property_info_area.LoadDefaultPath()) {
        LOG(FATAL) << "Failed to load serialized property info file";
    }
    ......
    PropertyLoadBootDefaults();  //开机加载默认属性配置prop文件
}

//读取selinux模块中的property相关文件，解析并加载到property_info中
void CreateSerializedPropertyInfo() {
    auto property_infos = std::vector<PropertyInfoEntry>();
    if (access("/system/etc/selinux/plat_property_contexts", R_OK) != -1) {
        if (!LoadPropertyInfoFromFile("/system/etc/selinux/plat_property_contexts",
                                      &property_infos)) {
            return;
        }
        // Don't check for failure here, so we always have a sane list of properties.
        // E.g. In case of recovery, the vendor partition will not have mounted and we
        // still need the system / platform properties to function.
        if (access("/system_ext/etc/selinux/system_ext_property_contexts", R_OK) != -1) {
            LoadPropertyInfoFromFile("/system_ext/etc/selinux/system_ext_property_contexts",
                                     &property_infos);
        }
        if (!LoadPropertyInfoFromFile("/vendor/etc/selinux/vendor_property_contexts",
                                      &property_infos)) {
            // Fallback to nonplat_* if vendor_* doesn't exist.
            LoadPropertyInfoFromFile("/vendor/etc/selinux/nonplat_property_contexts",
                                     &property_infos);
        }
        if (access("/product/etc/selinux/product_property_contexts", R_OK) != -1) {
            LoadPropertyInfoFromFile("/product/etc/selinux/product_property_contexts",
                                     &property_infos);
        }
        if (access("/odm/etc/selinux/odm_property_contexts", R_OK) != -1) {
            LoadPropertyInfoFromFile("/odm/etc/selinux/odm_property_contexts", &property_infos);
        }
    } else {
        if (!LoadPropertyInfoFromFile("/plat_property_contexts", &property_infos)) {
            return;
        }
        LoadPropertyInfoFromFile("/system_ext_property_contexts", &property_infos);
        if (!LoadPropertyInfoFromFile("/vendor_property_contexts", &property_infos)) {
            // Fallback to nonplat_* if vendor_* doesn't exist.
            LoadPropertyInfoFromFile("/nonplat_property_contexts", &property_infos);
        }
        LoadPropertyInfoFromFile("/product_property_contexts", &property_infos);
        LoadPropertyInfoFromFile("/odm_property_contexts", &property_infos);
    }

    auto serialized_contexts = std::string();
    auto error = std::string();
    if (!BuildTrie(property_infos, "u:object_r:default_prop:s0", "string", &serialized_contexts,
                   &error)) {
        LOG(ERROR) << "Unable to serialize property contexts: " << error;
        return;
    }
    //将序列化属性写入/dev/__properties__/property_info
    constexpr static const char kPropertyInfosPath[] = "/dev/__properties__/property_info";
    if (!WriteStringToFile(serialized_contexts, kPropertyInfosPath, 0444, 0, 0, false)) {
        PLOG(ERROR) << "Unable to write serialized property infos to file";
    }
    selinux_android_restorecon(kPropertyInfosPath, 0);
}
```

bionic\libc\bionic\system_property_api.cpp

```c++
__BIONIC_WEAK_FOR_NATIVE_BRIDGE
int __system_property_area_init() {
  bool fsetxattr_failed = false;
  return system_properties.AreaInit(PROP_FILENAME, &fsetxattr_failed) && !fsetxattr_failed ? 0 : -1;
}
```
bionic\libc\system_properties\system_properties.cpp

```c++
bool SystemProperties::AreaInit(const char* filename, bool* fsetxattr_failed) {
  if (strlen(filename) >= PROP_FILENAME_MAX) {
    return false;
  }
  strcpy(property_filename_, filename);

  contexts_ = new (contexts_data_) ContextsSerialized();
  if (!contexts_->Initialize(true, property_filename_, fsetxattr_failed)) {
    return false;
  }
  initialized_ = true;
  return true;
}
```
__system_property_area_init()经过一系列的方法调用，最终通过mmap()将/dev/__property __/property_info加载到共享内存。

system\core\property_service\libpropertyinfoparser\property_info_parser.cpp

```c++
bool PropertyInfoAreaFile::LoadDefaultPath() {
  return LoadPath("/dev/__properties__/property_info");
}

bool PropertyInfoAreaFile::LoadPath(const char* filename) {
    int fd = open(filename, O_CLOEXEC | O_NOFOLLOW | O_RDONLY);
    ...
      void* map_result = mmap(nullptr, mmap_size, PROT_READ, MAP_SHARED, fd, 0);
}
```

---


```c++

```


```c++

```


```c++

```

---


```sh

```


```sh

```

---

```sh

```

---

```sh

```

---

```sh

```

---


---

---

---



---


---


---




---

# 参考资料


---

[<font face='黑体' color=#ff0000 size=40 >跳转到文章开始</font>](#p26-系统开发之系统属性)

---

# 结束语

<img src="../Images/end_001.png">