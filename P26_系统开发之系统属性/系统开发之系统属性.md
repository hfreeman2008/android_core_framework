
# P26: 系统开发之系统属性

<img src="../flower/flower_p26.png">

---

[<font face='黑体' color=#ff0000 size=40 >跳转到文章结尾</font>](#结束语)

---

# 前言

系统属性是我们开发用的最多的一个技术点，以前觉得这个太简单了，没有什么需要了解的；后来想整体了解一下其具体的实现，发现事情没有那边简单啊。



本笔记主要是基于android 11，同步参考--Android 系统属性（SystemProperties）介绍（https://juejin.cn/post/7274932704453672972#heading-0）。

---

# 常用技巧

读取所有设备的系统属性：

```sh
adb shell getprop
```

读取对应的系统属性值（以sys.boot.reason为例）：


```sh
adb shell getprop sys.boot.reason
```

设置系统属性值（这个需要注意，许多系统属性值需要权限）：

```sh
adb shell setprop log.tag.stats_log D
```

监听系统属性值状态：

system/core/rootdir/init.rc

```sh
on property:vold.decrypt=trigger_restart_framework
    # A/B update verifier that marks a successful boot.
    exec_start update_verifier
    class_start_post_data hal
    class_start_post_data core
    class_start main
    class_start late_start
    setprop service.bootanim.exit 0
    start bootanim
```

---

# 代码中使用属性

## java代码调用

### 对于有系统权限的应用

我们可以直接使用SystemProperties的读写接口：

```java
import android.os.SystemProperties;

SystemProperties.set("sys.boot_completed", "1");
int max = SystemProperties.getInt("tombstoned.max_anr_count", 64);

```



这要求android程序的权限提升到system权限，方法有下面二个：

- 1、在AndroidManifest.xml中，在manifest加入android:sharedUserId="android.uid.system"。

- 2、在Android.mk中，將LOCAL_CERTIFICATE := XXX修改成LOCAL_CERTIFICATE := platform。

---

### 普通应用

由于SystemProperties.java的API为系统API，普通应用无法直接使用，可以通过反射来get和set prop。

```java
package com.android.reflectiondemo;

import androidx.appcompat.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Log.d(TAG, "sys.isolated_storage_snapshot:"+getBoolean("sys.isolated_storage_snapshot", false));
    }
    
    public static boolean getBoolean(String key, boolean def) throws IllegalArgumentException {
        try {
            Class SystemPropertiesClass = Class.forName("android.os.SystemProperties");
            Method getBooleanMethod =
                    SystemPropertiesClass.getDeclaredMethod(
                            "getBoolean", String.class, boolean.class);
            getBooleanMethod.setAccessible(true);
            return (boolean) getBooleanMethod.invoke(SystemPropertiesClass, key, def);
        } catch (InvocationTargetException
                | IllegalAccessException
                | NoSuchMethodException
                | ClassNotFoundException e) {
            Log.e(TAG, "Failed to invoke SystemProperties.getBoolean()", e);
        }
        return def;
    }
}

```



---

## c++代码调用

这里以MPEG4Writer.cpp为例

frameworks\av\media\libstagefright\MPEG4Writer.cpp

```c++
#include <cutils/properties.h>
    ...
void MPEG4Writer::addDeviceMeta() {
    ...
    if (property_get("ro.build.version.release", val, NULL)
    ...
        if (property_get("ro.product.model", val, NULL)
    ...
}

```

在C++代码中使用prop需要：
- include <cutils/properties.h>
- Android.mk或Android.bp或Makefile中需要链接libcutils库

```sh
shared_libs: [
        ...
        "libcutils",
        ...

```

properties.h源码在：

system/core/libcutils/include/cutils/properties.h

```c
int property_get(const char* key, char* value, const char* default_value);
int property_set(const char *key, const char *value);
int property_list(void (*propfn)(const char *key, const char *value, void *cookie), void *cookie)
```

libcutils库文件：

```sh
/system/lib64/libcutils.so
/system/lib/libcutils.so
```



---

# 涉及的代码路径汇总如下

```sh
app
SystemProperties#get  SystemProperties#set

framework：
frameworks\base\core\java\android\os\SystemProperties.java

jni:
frameworks\base\core\jni\android_os_SystemProperties.cpp

system:
system\core\base\properties.cpp
system\core\init\init.cpp
system\core\init\property_service.cpp
system\core\init\main.cpp
system\core\property_service\libpropertyinfoparser\property_info_parser.cpp

bionic:
bionic\libc\bionic\system_property_set.cpp
bionic\libc\bionic\system_property_api.cpp
bionic\libc\system_properties\system_properties.cpp
bionic\libc\include\sys\_system_properties.h
bionic\libc\include\sys\system_properties.h
bionic\libc\system_properties\contexts_serialized.cpp
bionic\libc\system_properties\prop_area.cpp
```

---

# 系统属性架构设计如下

![系统属性架构设计](系统属性架构设计.png)


---

# 系统属性整体分层

![系统属性整体分层](系统属性整体分层.png)

---

# 系统属性时序图

![系统属性时序图](系统属性时序图.png)


---

# 系统属性读写的流程

## frameworks-SystemProperties.java 
frameworks\base\core\java\android\os\SystemProperties.java 

读写系统属性的接口：

```java
public class SystemProperties {

    private static native String native_get(long handle);
    private static native void native_set(String key, String def);

    public static String get(@NonNull String key, @Nullable String def) {
        if (TRACK_KEY_ACCESS) onKeyAccess(key);
        return native_get(key, def);
    }
    
    public static void set(@NonNull String key, @Nullable String val) {
        if (val != null && !val.startsWith("ro.") && val.length() > PROP_VALUE_MAX) {
            throw new IllegalArgumentException("value of system property '" + key
                    + "' is longer than " + PROP_VALUE_MAX + " characters: " + val);
        }
        if (TRACK_KEY_ACCESS) onKeyAccess(key);
        native_set(key, val);
    }
}
```

通过JNI调用native_set()和native_get()：

---

## jni-android_os_SystemProperties.cpp
frameworks\base\core\jni\android_os_SystemProperties.cpp

```c++
//读
jstring SystemProperties_getSS(JNIEnv* env, jclass clazz, jstring keyJ,
                               jstring defJ)
{
    jstring ret = defJ;
    //读取系统属性
    ReadProperty(env, keyJ, [&](const char* value) {
        if (value[0]) {
            ret = env->NewStringUTF(value);
        }
    });
    if (ret == nullptr && !env->ExceptionCheck()) {
      ret = env->NewStringUTF("");  // Legacy behavior
    }
    return ret;
}

//写
void SystemProperties_set(JNIEnv *env, jobject clazz, jstring keyJ,
                          jstring valJ)
{
    ......
    bool success;
#if defined(__BIONIC__)
    //如果支持__BIONIC__
    success = !__system_property_set(key.c_str(), value ? value->c_str() : "");
#else
    //不支持__BIONIC__
    success = android::base::SetProperty(key.c_str(), value ? value->c_str() : "");
#endif
    if (!success) {
        jniThrowException(env, "java/lang/RuntimeException",
                          "failed to set system property (check logcat for reason)");
    }
}

//读
void ReadProperty(JNIEnv* env, jstring keyJ, Functor&& functor)
{
#if defined(__BIONIC__)
    //支持__BIONIC__
    const prop_info* prop = __system_property_find(key.c_str());
    if (!prop) {
        return;
    }
    ReadProperty(prop, std::forward<Functor>(functor));
#else
    //不支持__BIONIC__
    std::forward<Functor>(functor)(
        android::base::GetProperty(key.c_str(), "").c_str());
#endif
}

```


```c++
int register_android_os_SystemProperties(JNIEnv *env)
{
    const JNINativeMethod method_table[] = {
        { "native_get",
          "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
          (void*) SystemProperties_getSS },
        { "native_get_int", "(Ljava/lang/String;I)I",
          (void*) SystemProperties_get_integral<jint> },
        { "native_get_long", "(Ljava/lang/String;J)J",
          (void*) SystemProperties_get_integral<jlong> },
        { "native_get_boolean", "(Ljava/lang/String;Z)Z",
          (void*) SystemProperties_get_boolean },
        { "native_find",
          "(Ljava/lang/String;)J",
          (void*) SystemProperties_find },
        { "native_get",
          "(J)Ljava/lang/String;",
          (void*) SystemProperties_getH },
        { "native_get_int", "(JI)I",
          (void*) SystemProperties_get_integralH<jint> },
        { "native_get_long", "(JJ)J",
          (void*) SystemProperties_get_integralH<jlong> },
        { "native_get_boolean", "(JZ)Z",
          (void*) SystemProperties_get_booleanH },
        { "native_set", "(Ljava/lang/String;Ljava/lang/String;)V",
          (void*) SystemProperties_set },
        { "native_add_change_callback", "()V",
          (void*) SystemProperties_add_change_callback },
        { "native_report_sysprop_change", "()V",
          (void*) SystemProperties_report_sysprop_change },
    };
    return RegisterMethodsOrDie(env, "android/os/SystemProperties",
                                method_table, NELEM(method_table));
}
```



---

## system libbase库

```sh
vendor/lib64/libbase64.so
vendor/lib/libbase64.so
system/lib64/libbase.so
bengal/system/lib/libbase.so
```

android::base::GetProperty和android::base::SetProperty，调用的就是system libbase库中对应的文件：


system\core\base\properties.cpp

```c++
//读
std::string GetProperty(const std::string& key, const std::string& default_value) {
  std::string property_value;
#if defined(__BIONIC__)
  const prop_info* pi = __system_property_find(key.c_str());
  if (pi == nullptr) return default_value;

  __system_property_read_callback(pi,
                                  [](void* cookie, const char*, const char* value, unsigned) {
                                    auto property_value = reinterpret_cast<std::string*>(cookie);
                                    *property_value = value;
                                  },
                                  &property_value);
#else
  //读取系统属性
  auto it = g_properties.find(key);
  if (it == g_properties.end()) return default_value;
  property_value = it->second;
#endif
  // If the property exists but is empty, also return the default value.
  // Since we can't remove system properties, "empty" is traditionally
  // the same as "missing" (this was true for cutils' property_get).
  return property_value.empty() ? default_value : property_value;
}

//写
bool SetProperty(const std::string& key, const std::string& value) {
  return (__system_property_set(key.c_str(), value.c_str()) == 0);
}

#if !defined(__BIONIC__)
//这个是系统属性map
static std::map<std::string, std::string>& g_properties = *new std::map<std::string, std::string>;
static int __system_property_set(const char* key, const char* value) {
  //写
  g_properties[key] = value;
  return 0;
}
#endif
```

---

## bionic
bionic\libc\include\sys_system_properties.h

定义了系统属性服务名和系统属性文件：

```sh
#define PROP_SERVICE_NAME "property_service"
#define PROP_FILENAME "/dev/__properties__"
```


__system_property_set调用的写系统属性接口为：

bionic\libc\bionic\system_property_set.cpp

---



---

```sh

```

---

```sh

```

---

```sh

```

---


---

---

---



---


---


---




---

# 参考资料


---

[<font face='黑体' color=#ff0000 size=40 >跳转到文章开始</font>](#p26-系统开发之系统属性)

---

# 结束语

<img src="../Images/end_001.png">