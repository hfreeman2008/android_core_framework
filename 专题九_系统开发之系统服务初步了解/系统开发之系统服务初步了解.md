# 专题九: 系统开发之系统服务初步了解

<img src="flower_one.png">



# 一个mini系统服务----ContextHubSystemService

我们先看一个系统中的原生的mini的系统服务------ContextHubSystemService

```java
package com.android.server;

import android.content.Context;
import android.util.Log;
import com.android.internal.util.ConcurrentUtils;
import com.android.server.location.ContextHubService;
import java.util.concurrent.Future;

class ContextHubSystemService extends SystemService {

    private static final String TAG = "ContextHubSystemService";
    private ContextHubService mContextHubService;

    private Future<?> mInit;

    //(1)构造方法----一般来说必要
    public ContextHubSystemService(Context context) {
        super(context);
        mInit = SystemServerInitThreadPool.submit(() -> {
            mContextHubService = new ContextHubService(context);
        }, "Init ContextHubSystemService");
    }

    //(2)重写onStart()方法----一般来说必要
    @Override
    public void onStart() {
    }

    //(3)onBootPhase()方法----一般来说必要
    @Override
    public void onBootPhase(int phase) {
        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
            Log.d(TAG, "onBootPhase: PHASE_SYSTEM_SERVICES_READY");
            ConcurrentUtils.waitForFutureNoInterrupt(mInit,
                    "Wait for ContextHubSystemService init");
            mInit = null;
            publishBinderService(Context.CONTEXTHUB_SERVICE, mContextHubService);
        }
    }
}
```


可以看出，新写一个系统服务类，我们可以就写这三个方法：

- (1)构造方法----一般来说必要

- (2)重写onStart()方法----一般来说必要

- (3)onBootPhase()方法----一般来说必要


在SystemServer.java中启动ContextHubSystemService:

```java
t.traceBegin("StartContextHubSystemService");
mSystemServiceManager.startService(ContextHubSystemService.class);
t.traceEnd();
```

是不是足够简单，可以不夸张的说，就算是从深南大道上随便牵一条狗过来都可以写一个简单的系统服务。

<img src="dog.png">



# PHASE_XXXXXX指示了各个不同的启动阶段

在onBootPhase()方法，我们可以看到系统服务有相关的启动阶段，不同的启动阶段完成不同的逻辑。

主要的启动阶段：

```java
PHASE_WAIT_FOR_DEFAULT_DISPLAY,
PHASE_LOCK_SETTINGS_READY,
PHASE_SYSTEM_SERVICES_READY,
PHASE_DEVICE_SPECIFIC_SERVICES_READY,
PHASE_ACTIVITY_MANAGER_READY,
PHASE_THIRD_PARTY_APPS_CAN_START,
PHASE_BOOT_COMPLETED
```

其详细的定义为：

```java
public abstract class SystemService {
    /*
     * The earliest boot phase the system send to system services on boot.
     */
    public static final int PHASE_WAIT_FOR_DEFAULT_DISPLAY = 100;

    /**
     * After receiving this boot phase, services can obtain lock settings data.
     */
    public static final int PHASE_LOCK_SETTINGS_READY = 480;

    /**
     * After receiving this boot phase, services can safely call into core system services
     * such as the PowerManager or PackageManager.
     */
    public static final int PHASE_SYSTEM_SERVICES_READY = 500;

    /**
     * After receiving this boot phase, services can safely call into device specific services.
     */
    public static final int PHASE_DEVICE_SPECIFIC_SERVICES_READY = 520;

    /**
     * After receiving this boot phase, services can broadcast Intents.
     */
    public static final int PHASE_ACTIVITY_MANAGER_READY = 550;

    /**
     * After receiving this boot phase, services can start/bind to third party apps.
     * Apps will be able to make Binder calls into services at this point.
     */
    public static final int PHASE_THIRD_PARTY_APPS_CAN_START = 600;

    /**
     * After receiving this boot phase, services can allow user interaction with the device.
     * This phase occurs when boot has completed and the home application has started.
     * System services may prefer to listen to this phase rather than registering a
     * broadcast receiver for {@link android.content.Intent#ACTION_LOCKED_BOOT_COMPLETED}
     * to reduce overall latency.
     */
    public static final int PHASE_BOOT_COMPLETED = 1000;
}
```


# publishBinderService 和 publishLocalService

添加系统服务的时候，官方使用了 publishBinderService 和 publishLocalService。

它们的作用和区别是:

- publishBinderService发布的服务被加到ServiceManager中，可以通过getService获得，方便跨进程使用；

上面例子获取service的方式为我们常见的：

```java
ContextHubManager manager = (ContextHubManager) mContext.getSystemService(Context.CONTEXTHUB_SERVICE);
```


- publishLocalService 发布的服务被添加到LocalService的map中了，仅能系统进程访问；





# 参考资料



